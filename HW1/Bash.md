## Общий подход к решению

Токен -- подстрока входной строки, ограниченная пробелами с двух сторон.

Обработчик -- автомат, который имитирует работу CLI в соответствии с требованиями, состоит из следующих частей:

1. ``Reader`` -- модуль, который построчно обрабатывает входные строки, получаемые из терминала. Символом конца строки *
   *является символ "\n"**.
2. ``Parser`` -- модуль, который на вход получает считанную Readerом строку и разбивает ее на команды с соответствующими
   параметрами (если это возможно). Предварительно выполняет подстановку.
3. ``Checker`` -- модуль, отвечающий за проверку на валидность распарсенных команд и параметров.
4. ``Executor`` -- модуль, отвечающий за последовательный запуск команд со считанными параметрами, полученными на этапе
   парсинга и проверки.

Разрабатываемая программа является однопоточной, выполнение команд -- последовательное.

### Reader

Считывает из стандартного потока символы и конструирует строку из них, пока не будет введена команда exit.

#### Алгоритм работы Reader

1. Считывает из стандартного потока последовательности символов до тех пор, пока не встретит символ конца строки;
2. Формирует из считанной последовательности символов строку, которую передает на обработку ``Parser``;
3. Если ``Executor`` в конце передал сигнал, что последняя команда -- exit, ``Reader`` завершает свою работу;
4. Иначе -- переходит к п.1.

Если в стандартном потоке нет символов для считывания, находится в состоянии ожидания.

**Разделитель**: символ пробела.

### Parser

Состоит из двух частей:

1. ``Substitutor`` -- ищет в полученной на вход строке все возможные подстановки и выполняет их. Если выполнить
   подстановку не получается -- переменной нет в окружении -- заменяет подстановку на пустую строку;
2. ``Command parser`` -- модифицированную строку разбивает на команду/ы и параметры.

#### Алгоритм ``Substitutor``:

1. Поиск по подстроке мест, куда можно сделать подстановки
2. Подстановка переменных из окружения, если это возможно. Если переменной нет в окружении -- выдает ошибку.

#### Алгоритм ``Command Parser``:

1. Первый токен строки -- название команды. Если команд несколько, то командой считается или первый строки, или первый
   токен после символа ``|``;
2. Все следующие после названия команды токены, начинающиеся с символа ``-`` или ``--`` определяются как флаги команды;
3. Все следующие токены, следующие после последнего флага определяются как параметры команды.

Результатом работы ``Command Parser`` является список информации о каждой распарсенной команде.

Информация предоставляется в виде некоторой структуры, которая содержит следующие поля:

1. Название команды;
2. Список флагов (может быть пустым);
3. Список параметров (может быть пустым).

### Checker

Сопоставляет полученный список с информацией о командах с реальными командами, предусмотренными разрабатываемой
программой.

#### Алгоритм ``Checker``

1. Проверить название команды со списком доступных команд. Если название есть в списке, переход к п.2, иначе -- поиск
   в ``PATH``. Если в ``PATH`` такого названия команды нет, выдать ошибку. Возврат управления ``Reader``у;
2. Проверить список флагов у текущей рассматриваемой команды. Если флаг верный, то переход к п.3, если какой-либо флаг
   не является валидным для данной команды, выдать ошибку и вернуть управление ``Reader``у;
3. Если команда не из `PATH`, то параметры этой команды проходят базовые проверки, иначе -- переход к п.4. Если все
   параметры валидны, то переход к п.4, если какой-то параметр не проходит проверку, то выдать ошибку и вернуть
   управление ``Reader`у;
4. Если еще есть непроверенные команды, переход к следующей в списке команде и к п.1, иначе -- к п.5;
5. Передача проверенного списка команд ``Executor``у.

Ошибка неправильной команды: содержит информацию об имени соответствующей команды.

Ошибка неправильного флага: содержит информацию о том, что соответствующая команда не содержит такой флаг + информация о
существующих флагах для этой команды.

Ошибка неправильного параметра: содержит информацию о том, что соответствующей команде передали неправильный параметр +
информация о том, какой параметр ожидается.

| Название команды | Проверки                                                                                                                                                                                                                                                                               |
|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| cat              | 1. Параметров нет: поток для вывода: стандартный output; </br> 2. Первый параметр есть: проверить, что есть такой файл; </br> 3. Первый параметр знак ``>``: </br> &nbsp; 3.1. Второй параметр есть: создание файла под именем=второй параметр, запись в файл пока не будет встречена  |
| wc               |                                                                                                                                                                                                                                                                                        |
| pwd              |                                                                                                                                                                                                                                                                                        |
| exit             |                                                                                                                                                                                                                                                                                        | 

### Executor

[//]: # (переписать бы в нормальном виде, как пошаговый алгоритм, как у предыдущих)

Последовательно выполняет все команды из списка команд, пока не достигнет конца списка. После этого возвращает управление ``Reader``у. Результат выполнения команды (если она что-то возвращает) передается как последний параметр следующей команде из списка.

Если результат выполнения последней команды из списка присутствует, то он выводится в стандартный поток вывода. 

```Если какая-то команда из списка завершается неудачей, результат выполнения предыдущих команд не откатывается, управление возвращается ``Reader``у, выполнение всех последующих команд из списка прерывается```

## Краевые случаи

1. **Проблема**: Получение после подстановки валидных команд:

```shell
x=ex
y=it
$x$y
```

**Решение**: в считанной строке сначала производим все подставления, если это возможно (если мы можем это сделать), и
только затем -- парсинг на команды

2. **Проблема** : Подстановка переменной, которой нет в окружении.

   **Решение**: Обрабатываем такие случаи как ошибочные команды.
3. **Проблема**: Рекурсивная подстановка

   **Решение**: Синтаксическое ограничение для невозможности воспроизведения рекурсивной подстановки.
4. **Проблема**: Лишние проблемы между токенами и/или в начале/конце строки.

   **Решение**: ``Command Parser`` игнорирует пробелы в начале строки и в конце строки, если между токенами встречается
   более одного пробела, они так же игнорируются и не включаются в часть команды/параметра.
5. **Проблема**: Поведение двойных кавычек в различных командах

   **Решение**:
6. **Проблема**: Поведение одинарных кавычек в различных командах

   **Решение**:

## Определение классов

### Команды

Каждая команда определена в соответствующем классе, который обрабатывает различные случаи 